[{"title":"AJAX","date":"2022-03-05T08:25:37.000Z","path":"2022/03/05/AJAX/","text":"AjaxAJAX简介AJAX全称为Asynchronous JavasSript And XML，就是异步的js和xml。通过AJAX可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据。AJAX不是新的编程语言，而是将现有的标准组合在一起使用的新方式。 XML 简介XML(可拓展标记语言),被设计用来传输和存储数据。XML 和 HTML 类似，不同的是 HTML 都是预定义标签，而 XML 中没有预定义标签，全部都是自定义标签，用来表示一些数据 例如： 1234567&lt;!-- 比如有一个学生数据：name=&quot;Andy&quot;;age=&quot;18&quot;;sex=&quot;男&quot; --&gt;&lt;!-- 用xml来表示 --&gt;&lt;student&gt;&lt;name&gt;Andy&lt;/name&gt;&lt;age&gt;18&lt;/age&gt;&lt;sex&gt;男&lt;/sex&gt;&lt;/student&gt; 但是现在已经被 json 取代了用 json 表示 12345&#123; &quot;name&quot;: &quot;Andy&quot;, &quot;age&quot;: &quot;18&quot;, &quot;sex&quot;: &quot;男&quot;&#125; Ajax 的特点AJAX 优点 可以无需刷新页面而与服务器进行通信 允许你根据用户事件来更新部分页面内容 AJAX 缺点 没有浏览历史，不能回退 存在跨域问题（同源） SEO(搜索引擎优化)不友好 HTTP 协议HTTP 协议(超文本传输协议)，详细规定了浏览器与万维网服务器之间互相通信的规则 请求报文重点是格式和参数 1234567行 POST /s?ie=utf-8 HTTP/1.1头 Host: baidu.com Cookie: name=baidu Content-type: application/x-www-form-urlencoded User-Agent: chrome 83空行体 username=admin&amp;password=admin 响应报文123456789101112行 HTTP/1.1 200 OK头 Content-Type: text/html;charset=utf-8 Content-length:2048 Content-encoding:gzip空行体 &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;body&gt; &lt;/html&gt; 安装 express 初始化 1npm i --y 安装 express 1npm express 使用 Ajax 进行网络请求前端代码 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; let button=document.querySelector(&quot;button&quot;) let div=document.querySelector(&quot;div&quot;) button.addEventListener(&#x27;click&#x27;,function()&#123; // 1.创建对象 const xhr = new XMLHttpRequest(); // 2.初始化 设置请求方法和url xhr.open(&#x27;GET&#x27;,&quot;http://localhost:8080/serve&quot;) //3.发送 xhr.send(); // 4. 事件绑定,处理服务端返回的结果 // on 当...的时候 // readystate 是xhr对象中的属性，表示状态 // 0 未初始化 1 open()方法调用完毕 2 send()方法调用完毕 3 服务端返回部分结果 4 服务端返回所有结果 // change 改变 xhr.onreadystatechange=function()&#123; // 判断(服务端返回了所有的结果) if(xhr.readyState===4)&#123; // 判断相应状态码 200 404 403 500 // 2xx 表示成功 if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)&#123; console.log(xhr.status); //状态码 console.log(xhr.statusText);//状态字符串 console.log(xhr.getAllResponseHeaders());//所有响应头 console.log(xhr.response);//响应体 div.innerHTML=xhr.response;//将相应体内容渲染到div中 &#125; else&#123; console.log(&quot;error&quot;) &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后端代码： 1234567891011121314151617181920// 引入expressconst express = require(&quot;express&quot;);// 创建应用对象const app = express();// 创建路由规则// request 是对请求报文的封装// response 是对响应报文的封装app.get(&quot;/serve&quot;, (request, response) =&gt; &#123; // 设置响应头 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 设置响应体 response.send(&quot;hello express&quot;);&#125;);// 4.监听端口启动服务app.listen(8080, () =&gt; &#123; console.log(&quot;服务已启动，8080&quot;);&#125;); Ajax 设置请求参数通过地址栏传参例如： 1https://www.baidu.com/s?wd=bilibili //访问百度搜索哔哩哔哩结果 在 Ajax 中，也可在 url 后面追加参数例如： 1http://localhost:3000?a=100&amp;b=200&amp;c=300 Ajax 发送 post 请求serve.js 1234567891011121314151617181920212223242526// 引入expressconst express = require(&quot;express&quot;);// 创建应用对象const app = express();// 创建路由规则// request 是对请求报文的封装// response 是对响应报文的封装app.get(&quot;/serve&quot;, (request, response) =&gt; &#123; // 设置响应头 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 设置响应体 response.send(&quot;hello express&quot;);&#125;);app.post(&quot;/serve&quot;, (request, response) =&gt; &#123; // 设置响应头 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 设置响应体 response.send(&quot;hello express POST&quot;);&#125;);// 4.监听端口启动服务app.listen(8080, () =&gt; &#123; console.log(&quot;服务已启动，8080&quot;);&#125;); index.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; height: 100px; width: 200px; border: solid 1px skyblue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; let button = document.querySelector(&quot;button&quot;); let div = document.querySelector(&quot;div&quot;); button.addEventListener(&quot;click&quot;, function () &#123; // 1.创建对象 const xhr = new XMLHttpRequest(); // 2.初始化 设置请求方法和url xhr.open(&quot;POST&quot;, &quot;http://localhost:8080/serve&quot;); //3.发送 xhr.send(&quot;a=100&amp;b=200&amp;c=300&quot;); //post请求可以设置参数 // 4. 事件绑定,处理服务端返回的结果 // on 当...的时候 // readystate 是xhr对象中的属性，表示状态 // 0 未初始化 1 open()方法调用完毕 2 send()方法调用完毕 3 服务端返回部分结果 4 服务端返回所有结果 // change 改变 xhr.onreadystatechange = function () &#123; // 判断(服务端返回了所有的结果) if (xhr.readyState === 4) &#123; // 判断相应状态码 200 404 403 500 // 2xx 表示成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; console.log(xhr.status); //状态码 console.log(xhr.statusText); //状态字符串 console.log(xhr.getAllResponseHeaders()); //所有响应头 console.log(xhr.response); //响应体 div.innerHTML = xhr.response; //将相应体内容渲染到div中 &#125; else &#123; console.log(&quot;error&quot;); &#125; &#125; &#125;; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 设置请求头信息在 open 方法后面使用 setRequestHeader 方法 1xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;)//设置请求报文格式 还可以设置自定义方法例如： 1xhr.setRequestHeader(&#x27;name&#x27;,&#x27;Andy&#x27;) 但是设置自定义方法需要在后端设置允许自定义头，并使用 all 请求 12345678app.all(&#x27;/serve&#x27;,(request,response)=&gt;&#123; // 设置响应头 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;) response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;*&#x27;) // 设置响应体 response.send(&#x27;hello express POST&#x27;) &#125;) 服务端响应 json 数据index.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; height: 100px; width: 200px; border: solid 1px skyblue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; let button = document.querySelector(&quot;button&quot;); let div = document.querySelector(&quot;div&quot;); button.addEventListener(&quot;click&quot;, function () &#123; // 1.创建对象 const xhr = new XMLHttpRequest(); xhr.responseType = &quot;json&quot;; //设置响应体对象类型 // 2.初始化 设置请求方法和url xhr.open(&quot;get&quot;, &quot;http://localhost:8080/serve/json&quot;); //3.发送 xhr.send(); xhr.onreadystatechange = function () &#123; // 判断(服务端返回了所有的结果) if (xhr.readyState === 4) &#123; // 判断相应状态码 200 404 403 500 // 2xx 表示成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; console.log(xhr.status); //状态码 console.log(xhr.statusText); //状态字符串 console.log(xhr.getAllResponseHeaders()); //所有响应头 console.log(xhr.response); //响应体 //手动转换 // let data=JSON.parse(xhr.response) // div.innerHTML=data.name; //自动转换，需设置xhr响应对象类型 第25行 div.innerHTML = xhr.response.name; &#125; else &#123; console.log(&quot;error&quot;); &#125; &#125; &#125;; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; serve.js 1234567891011121314151617181920// 引入expressconst express = require(&quot;express&quot;);// 创建应用对象const app = express();app.get(&quot;/serve/json&quot;, (request, response) =&gt; &#123; // 设置响应头 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 设置响应体 const data = &#123; name: &quot;Andy&quot;, &#125;; let str = JSON.stringify(data); response.send(str); //只能发送字符串&#125;);// 4.监听端口启动服务app.listen(8080, () =&gt; &#123; console.log(&quot;服务已启动，8080&quot;);&#125;); nodemon 自动重启工具安装 nodemon 工具后更新 serve.js 代码后无需手动重启服务安装指令 1npm i -g nodemon 请求超时与网络异常处理1234567891011//1.请求超时//设置超时时间2sxhr.timeout=2000// 超时回调xhr.ontimeout=function()&#123; alert(&quot;网络请求超时&quot;)&#125;//2.网络异常xhr.onerror=function()&#123; alert(&quot;网络异常&quot;)&#125; 取消请求abort 方法可以取消请求示例代码index.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;button&gt;点击取消请求&lt;/button&gt; &lt;script&gt; let btns = document.querySelectorAll(&quot;button&quot;); let xhr = null; btns[0].addEventListener(&quot;click&quot;, function () &#123; xhr = new XMLHttpRequest(); xhr.open(&quot;get&quot;, &quot;http://localhost:8080/serve/delay&quot;); xhr.send(); &#125;); btns[1].addEventListener(&quot;click&quot;, function () &#123; xhr.abort(); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; serve.js 12345678910111213141516// 引入expressconst express = require(&quot;express&quot;);// 创建应用对象const app = express();app.get(&quot;/serve/delay&quot;, (request, response) =&gt; &#123; // 设置响应头 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 设置响应体 setTimeout(() =&gt; &#123; response.send(&quot;hello express&quot;); &#125;, 3000);&#125;);// 4.监听端口启动服务app.listen(8080, () =&gt; &#123; console.log(&quot;服务已启动，8080&quot;);&#125;); 重复发送请求问题如果用户一直向服务器发送请求会导致服务器压力过大解决方法：判断用户有无发送重复请求，如果有，则取消之前的请求重新发送一个新的请求。示例代码： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;script&gt; let btns = document.querySelectorAll(&quot;button&quot;); let xhr = null; //表示变量, 判断是否正在发送ajax请求 let isSending = false; btns[0].addEventListener(&quot;click&quot;, function () &#123; if (isSending) &#123; xhr.abort(); //如果请求正在发送，则取消该请求。 &#125; xhr = new XMLHttpRequest(); // 修改标识变量的值 isSending = true; xhr.open(&quot;get&quot;, &quot;http://localhost:8080/serve/delay&quot;); xhr.send(); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; // 修改标识变量 isSending = false; &#125; &#125;; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; serve.js 代码与上一节一致 jquery 发送 Ajax 请求 get 请求 1$.get(url,[data],[callback],[type]) 属性 作用 url 请求的 url 地址 data 请求携带的参数 callback 载入成功时回调函数 type 设置返回内容格式(xml、html、script、json、test) post 请求 1$.post(url,[data],[callback],[type]) 通用方法 1234567$.ajax(&#123; url: &quot;test.html&quot;, cache: false, success: function(html)&#123; $(&quot;#results&quot;).append(html); &#125;&#125;); 其他更多设置可访问https://jquery.cuishifeng.cn/jQuery.Ajax.html 示例代码：index.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; integrity=&quot;sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu&quot; crossorigin=&quot;anonymous&quot; /&gt; &lt;script src=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js&quot; integrity=&quot;sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd&quot; crossorigin=&quot;anonymous&quot; &gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;点击发送GET请求&lt;/button&gt; &lt;button class=&quot;btn btn-success&quot;&gt;点击发送POST请求&lt;/button&gt; &lt;button class=&quot;btn btn-info&quot;&gt;通用型方法ajax&lt;/button&gt; &lt;script&gt; $(function () &#123; $(&quot;button&quot;) .eq(0) .click(function () &#123; $.get( &quot;http://localhost:8080/serve&quot;, &#123; a: 100, b: 200 &#125;, function (data) &#123; console.log(data); &#125; ); &#125;); $(&quot;button&quot;) .eq(1) .click(function () &#123; $.post( &quot;http://localhost:8080/serve&quot;, &#123; a: 100, b: 200 &#125;, function (data) &#123; console.log(data); &#125; ); &#125;); $(&quot;button&quot;) .eq(2) .click(function () &#123; $.ajax(&#123; //url url: &quot;http://localhost:8080/serve&quot;, //参数 data: &#123; a: 100, b: 200 &#125;, // 请求类型 type: &quot;GET&quot;, //成功时的回调 success: function (data) &#123; console.log(data); &#125;, // 失败时的回调 error: function () &#123; console.log(&quot;error&quot;); &#125;, &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; serve.js 1234567891011121314// 引入expressconst express = require(&quot;express&quot;);// 创建应用对象const app = express();app.all(&quot;/serve&quot;, (request, response) =&gt; &#123; // 设置响应头 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 设置响应体 response.send(&quot;hello jquery Ajax&quot;);&#125;);// 4.监听端口启动服务app.listen(8080, () =&gt; &#123; console.log(&quot;服务已启动，8080&quot;);&#125;); axios 发送 ajax 请求get 请求12345678910111213141516171819202122232425262728293031323334353637383940414243const axios = require(&quot;axios&quot;);// Make a request for a user with a given IDaxios .get(&quot;/user?ID=12345&quot;) .then(function (response) &#123; // handle success console.log(response); &#125;) .catch(function (error) &#123; // handle error console.log(error); &#125;) .then(function () &#123; // always executed &#125;);// Optionally the request above could also be done asaxios .get(&quot;/user&quot;, &#123; params: &#123; ID: 12345, &#125;, &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;) .then(function () &#123; // always executed &#125;);// Want to use async/await? Add the `async` keyword to your outer function/method.async function getUser() &#123; try &#123; const response = await axios.get(&quot;/user?ID=12345&quot;); console.log(response); &#125; catch (error) &#123; console.error(error); &#125;&#125; post 请求1234567891011axios .post(&quot;/user&quot;, &#123; firstName: &quot;Fred&quot;, lastName: &quot;Flintstone&quot;, &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); axios 函数1234567891011121314151617// Send a POST requestaxios(&#123; method: &quot;post&quot;, url: &quot;/user/12345&quot;, data: &#123; firstName: &quot;Fred&quot;, lastName: &quot;Flintstone&quot;, &#125;,&#125;);// GET request for remote image in node.jsaxios(&#123; method: &quot;get&quot;, url: &quot;http://bit.ly/2mTM3nY&quot;, responseType: &quot;stream&quot;,&#125;).then(function (response) &#123; response.data.pipe(fs.createWriteStream(&quot;ada_lovelace.jpg&quot;));&#125;); 更多用法查询网址 https://github.com/axios/axios#axios-api 使用 fetch 函数发送 ajax 请求用法：https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch示例代码：index.html 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.26.0/axios.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;点击发送请求&lt;/button&gt; &lt;script&gt; let button = document.querySelector(&quot;button&quot;); button.addEventListener(&quot;click&quot;, function () &#123; fetch(&quot;http://localhost:8080/serve&quot;, &#123; // 请求方法 method: &quot;post&quot;, // 请求体 body: &#123; username: &quot;admin&quot;, password: &quot;123456&quot;, &#125;, &#125;) .then((response) =&gt; &#123; return response.text(); &#125;) .then((response) =&gt; &#123; console.log(response); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; serve.js 1234567891011121314// 引入expressconst express = require(&quot;express&quot;);// 创建应用对象const app = express();app.all(&quot;/serve&quot;, (request, response) =&gt; &#123; // 设置响应头 response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 设置响应体 response.send(&quot;hello fetch&quot;);&#125;);// 4.监听端口启动服务app.listen(8080, () =&gt; &#123; console.log(&quot;服务已启动，8080&quot;);&#125;); 跨域同源策略 同源策略最早由 Netscape 公司提出，是浏览器的一种安全策略。 同源：协议、域名、端口号必须完全相同 违背同源策略就是跨域 如何解决跨域JSONP JSONP 是什么JSONP(json with padding)，是一个非官方的跨域解决方案，纯粹是凭借程序员的聪明才智开发出来，只支持 get 请求 JSONP 怎么工作的？在网页内有一些标签天生具有跨域能力，比如：img link iframe scriptJSONP 就是利用 script 标签的跨域能力来发送跨域请求的 CORS CORS 是什么 CORS(Cross-Origin Resource Sharing),跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器由权限访问哪些资源 CORS 怎么工作的？ CORS 是通过一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行","tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://example.com/tags/AJAX/"}]},{"title":"jQuery","date":"2022-02-27T09:42:32.000Z","path":"2022/02/27/jQuery/","text":"jquery 入口函数方式一： 123$(document).ready(function () &#123; // code&#125;); 方式二： 123$(function () &#123; // code&#125;); 这两种方式是等 DOM 结构渲染完毕即可执行内部代码 DOM 对象和 jQuery 对象 用 js 传统方式获取过来的就是 DOM 对象，用 jQuery 方式获取过来的是 jQuery 对象，jQuery 对象只能使用 jQuery 的属性和方法，DOM 对象使用 js 原生的属性和方法。 DOM 对象与 jQuery 对象之间是可以相互转换的因为 js 比 jQuery 更大，原生的一些属性和方法 jQuery 没有给我们封装，要想使用这些方法需要把 jQuery 对象转换为 DOM 对象才能使用1.DOM 对象转换为 jQuery 对象： $(DOM 对象) 12let div = document.querySelector(&quot;div&quot;);$(div); 2.jQuery 对象转换为 DOM 对象（两种方式） 12345// 第一种$(&#x27;div&#x27;)[index] index是索引号//第二种$(&#x27;div&#x27;).get(index) index是索引号 jQuery 常用 APIapi 查询网址 https://jquery.cuishifeng.cn/ jQuery 选择器jQuery 基础选择器1$(&quot;选择器&quot;); //里面选择器直接写css选择器即可，但是要加引号 名称 用法 描述 id 选择器 $(“#id”) 获取指定 id 的元素 全选选择器 $(“*“) 匹配所有元素 类选择器 $(“.class”) 获取同一类 class 的元素 标签选择器 $(“div”) 获取同一类标签的所有元素 并集选择器 $(“div,p,li”) 获取多个元素 交集选择器 $(“li.current”) 交集元素 子代选择器 $(“ul&gt;li”) 使用&gt;号，获取亲儿子层级的元素；注意，并不会获取孙子层级的元素 后代选择器 $(“ul li”) 使用空格，代表后代选择器，获取 ul 下的所有 li 元素，包括孙子等 jQuery 设置样式 1$(&quot;div&quot;).css(&quot;属性&quot;, &quot;值&quot;); jQuery 筛选选择器 语法 用法 描述 :first $(“li:first”) 获取第一个 li 元素 :last $(“li:last”) 获取最后一个 li 元素 :eq(index) $(“li:eq(2)”) 选择获取到的 li 元素索引号为 2 的元素，索引号从 0 开始 :odd $(“li:odd”) 获取索引号为奇数的元素 :even $(“li:even”) 获取索引号为偶数的元素 jQuery 筛选方法 语法 用法 说明 parent() $(“li”).parent() 查找父级 children(selector) $(“ul”).children(“li”) 相当于$(“ul&gt;li”) find(selector) $(“ul”).find(“li”) 相当于$(“ul li”) siblings(selector) $(“first”).siblings(“li”) 查找兄弟节点，不包括自己本身 nextAll([expr]) $(“.first”).nextAll() 查找当前元素之后所有的同辈元素 prevAll([expr]) $(“.last”).prevAll() 查找当前元素之前的所有同辈元素 hasClass(class) $(“div”).hasClass(“protected”) 检查当前的元素是否含有某个特定的类，如果有，则返回 true eq(index) $(“li”).eq(2) 相当于$(“li:eq(2)”),index 从 0 开始 jQuery 排他思想示例代码 123456789101112131415161718192021&lt;body&gt; &lt;button&gt;点击&lt;/button&gt; &lt;button&gt;点击&lt;/button&gt; &lt;button&gt;点击&lt;/button&gt; &lt;button&gt;点击&lt;/button&gt; &lt;button&gt;点击&lt;/button&gt; &lt;script&gt; $(function ()&#123;&quot; &quot;&#125; &#123; //隐式迭代，给所有按钮都绑定了点击事件 $(&quot;button&quot;).click(function () &#123; // 2.当前的元素变化背景颜色 $(this).css(&quot;background&quot;, &quot;skyblue&quot;); // 其余兄弟节点去掉背景颜色 $(this).siblings(&quot;button&quot;).css(&quot;background&quot;, &quot;&quot;); &#125;) &#125; ) &lt;/script&gt;&lt;/body&gt; 链式编程 链式编程是为了节约代码量，看起来更优雅 例如上个例子中的 123$(this).css(&quot;background&quot;, &quot;skyblue&quot;);$(this).siblings(&quot;button&quot;).css(&quot;background&quot;, &quot;&quot;); 可以简化为 1$(this).css(&quot;background&quot;, &quot;skyblue&quot;).siblings(&quot;button&quot;).css(&quot;background&quot;, &quot;&quot;); jQuery 样式操作操作 css 方法jQuery 可以使用 css 方法来修改简单元素样式，也可以操作类，修改多个样式 参数只写属性名，则返回属性值 1$(this).css(&quot;color&quot;); 参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号 1$(this).css(&quot;color&quot;, &quot;red&quot;); 参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开，属性可以不用加引号 12$(this).css(&#123; backgroundColor: &quot;white&quot;, &quot;font-size&quot;: &quot;20px&quot; &#125;);// 注意：如果属性为复合属性，则必须使用驼峰命名法 设置类样式方法 添加类 12$(&quot;div&quot;).addClass(&quot;current&quot;);// current 为提前在css中写好的类名 移除类 1$(&quot;div&quot;).removeClass(&quot;current&quot;); 切换类 12$(&quot;div&quot;).toggleClass(&quot;current&quot;);// 如果有current类名则移除，没有则添加 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./jquery.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; body&#123; height: 96vh; display: flex; justify-content: center; align-items: center; &#125; div&#123; height: 200px; width: 200px; background-color: red; &#125; .current&#123; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt;adads $(function()&#123; // $(&quot;div&quot;).click(function()&#123; // $(this).addClass(&quot;current&quot;) // &#125;) // $(&quot;div&quot;).click(function()&#123; // $(this).removeClass(&quot;current&quot;) // &#125;) $(&quot;div&quot;).click(function()&#123; $(this).toggleClass(&quot;current&quot;) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 类操作与 className 的区别原生 js 中 className 会覆盖元素元素原先里面的类名jQuery 里面类操作只是对指定类进行操作，不影响原先的类名 jQuery 效果显示与隐藏效果 显示隐藏语法规范 123show([speed], [easing], [fn]); //显示hide([speed], [easing], [fn]); //隐藏toggle([speed], [easing], [fn]); //切换 参数 参数都可以省略，无动画直接显示（一般情况下都不加参数） speed：三种预定速度之一的字符串（”slow”,”normal”,”fast”）或表示动画时长的毫秒数值（如：1000） easing： （Optional）用来指定切换效果，默认是 swing，可用参数”linear” fn: 回调函数，在动画完成时执行的函数，每个元素执行一次 滑动效果123slideUp([[speed, [easing]], [fn]]); // 上滑slideDown([[speed, [easing]], [fn]]); // 下滑slideToggle([[speed, [easing]], [fn]]); // 切换 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./jquery.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; div &#123; background-color: skyblue; height: 500px; width: 200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;上滑&lt;/button&gt; &lt;button&gt;下滑&lt;/button&gt; &lt;button&gt;切换&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function () &#123; $(&quot;button&quot;) .eq(0) .click(function () &#123; $(&quot;div&quot;).slideUp(); &#125;); $(&quot;button&quot;) .eq(1) .click(function () &#123; $(&quot;div&quot;).slideDown(); &#125;); $(&quot;button&quot;) .eq(2) .click(function () &#123; $(&quot;div&quot;).slideToggle(); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 事件切换1hover[([over], out)]; over: 鼠标移到元素上要触发的函数（相当于 mouseenter）out： 鼠标移出元素要触发的函数（相当于 mouseleave） 动画队列及停止排队方法 动画或效果队列动画效果一旦触发就会执行，如果多次触发，就造成多个动画效果排队执行 停止排队 1stop(); (1) stop 方法用于停止动画或效果(2)注意： stop()写到动画或者效果的前面，相当于停止结束上一次的动画 自定义动画 语法 1animate(params, [speed], [easing], [fn]); 参数 params:想要更改的样式属性，以对象的形式传递，必须写。属性名可以不用带引号，如果是复合属性则需要采取驼峰命名法，其余参数都可以省略。 speed：三种预定速度之一的字符串（”slow”,”normal”,”fast”）或表示动画时长的毫秒数值（如：1000） easing： （Optional）用来指定切换效果，默认是 swing，可用参数”linear” fn: 回调函数，在动画完成时执行的函数，每个元素执行一次 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./jquery.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; div &#123; position: absolute; height: 200px; width: 200px; background-color: skyblue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;动画效果&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function () &#123; $(&quot;button&quot;).click(function () &#123; $(&quot;div&quot;).animate( &#123; left: 100, top: 300, width: 500, opacity: 0.4, &#125;, 500 ); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; jQuery 属性操作设置或获取元素固有属性值 prop()所谓元素固有属性就是元素本身自带的属性，比如&lt; a &gt;元素里的 href 1.获取属性语法1props(&quot;属性&quot;); 2.设置属性语法1prop(&quot;属性&quot;, &quot;属性值&quot;); 设置或获取元素自定义属性 attr()用户自己给元素添加的属性，我们称为自定义属性，比如给 div 添加 index=”1”. 1.获取属性语法1attr(&quot;属性&quot;); //类似原生getAttribute() 2.设置属性语法1attr(&quot;属性&quot;, &quot;属性值&quot;); //类似原生setAttriubute() jQuery 内容文本值主要针对元素的内容还有表单的值操作 普通元素内容 html()(相当于原生 innerHTML) 12html(); //获取元素的内容html(&quot;内容&quot;); //设置元素的内容 普通元素文本内容 text() (相当于原生 innerText) 12text(); //获取元素的文本内容text(&quot;文本内容&quot;); //设置元素的文本内容 表单元素的值 val() (相当于原生 value) 12val(); //获取元素的文本内容val(&quot;文本内容&quot;); //设置元素的文本内容 jQuery 元素操作主要是遍历、创建、添加、删除元素操作 遍历元素jQuery 隐式迭代是对同一类元素做了同样的操作，如果想要给同一类元素做不同操作，就需要用到遍历。 语法 1： 123$(&quot;div&quot;).each(function (index, domEle) &#123; xxx;&#125;); each()方法遍历匹配的每一个元素，主要用 DOM 处理。 2.里面的回调函数有两个参数： index 是每个元素的索引号，demEle 是每个元素的 DOM 元素对象，不是 jquery 对象 示例代码： 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 通过遍历给三个div设置不同颜色 --&gt; &lt;div&gt;第一个div&lt;/div&gt; &lt;div&gt;第二个div&lt;/div&gt; &lt;div&gt;第三个div&lt;/div&gt; &lt;script&gt; $(function () &#123; let arr = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; $(&quot;div&quot;).each(function (i, element) &#123; //回调参数第一个一定是索引号，可以自己指定索引号名称 console.log(i); //回调参数第二个参数一定是DOM对象 console.log(element); //DOM对象没有css方法，需要转化为jquery对象 $(element).css(&quot;color&quot;, arr[i]); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 语法 2： 123$.each(object, function (index, element) &#123; xxx;&#125;); $.each()方法可用于遍历任何对象，主要用于数据处理，比如数组、对象 里面的函数有两个参数： index 是每个元素的索引号，element 是遍历内容 创建元素语法： 1$(&quot;&lt;li&gt;&lt;/li&gt;&quot;); 动态的创建了一个&lt; li &gt; 添加元素内部添加1element.append(&quot;内容&quot;); 把内容放入匹配元素的最后面，类似于原生 appendChild 1element.prepend(&quot;内容&quot;); 把内容放入匹配元素的最前面 外部添加1element.after(&quot;内容&quot;); //把内容放入目标元素后面 1element.before(&quot;内容&quot;); //把内容放入目标元素前面 内部添加元素，生成之后，他们是父子关系外部添加元素，生成之后，他们是兄弟关系 删除元素1element.remove(); //删除匹配的元素（本身） 1element.empty(); //删除匹配的元素集合中的所有子节点 1element.html(&quot;&quot;); //清空匹配的元素内容 示例代码： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;初始li&lt;/li&gt; &lt;/ul&gt; &lt;div&gt;初始div&lt;/div&gt; &lt;script&gt; $(function () &#123; // 1.创建元素 let li = $(&quot; &lt;li&gt;后来创建的li&lt;/li&gt;&quot;); // 2.添加元素 // (1)内部添加 // $(&quot;ul&quot;).append(li); $(&quot;ul&quot;).prepend(li); // (2)外部添加 let div = $(&quot;&lt;div&gt;我是后来创建的div&lt;/div&gt;&quot;); // $(&quot;div&quot;).after(div); $(&quot;div&quot;).before(div); // 3.删除元素 // $(&#x27;ul&#x27;).remove();//可以删除匹配的元素 // $(&#x27;ul&#x27;).empty();//删除匹配元素里面的子节点 $(&quot;ul&quot;).html(&quot;&quot;); //清空匹配的元素内容 &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; jquery 尺寸和位置jquery 尺寸方法 语法 用法 width() / height() 取得匹配元素的宽度和高度值 只算 width/height innerWidth() / innerHeight() 取得匹配元素的宽度和高度值 包含 padding outerWidth() / outerHeight() 取得匹配元素的宽度和高度值 包含 padding、border outerWidth(true) / outerHeight(true) 取得匹配元素的宽度和高度值 包含 padding、border、margin 以上参数为空，则是获取相应值，返回的是数字型 如果参数为数字，则是修改相应值 参数可以不必写单位 jquery 位置 offset()设置或获取元素偏移 offset()方法设置或返回被选元素相对于文档的偏移坐标，跟父级没有关系 该方法有两个属性 left、top。offset().top 用于获取距离文档顶部的距离，offset().left 用于获取距离文档左侧的距离。 可以设置元素的偏移：offset({top:10;left:30}); position()获取元素偏移 position()方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为准。 scrollTop()/scrollLeft()设置或获取元素被卷去的头部或左侧 scrollTop()设置或返回被选元素被卷去的头部 scrollLeft()设置或返回被选元素被卷去的左侧 jquery 事件jquery 事件注册单个事件注册语法： 12345element.事件(function () &#123;&#125;);// 例如：$(&quot;div&quot;).click(function () &#123; 事件处理程序;&#125;); 其他事件和原生基本一致比如 mouseover、mouseout、blur、focus、change、keydown、keyup、resize、scroll 等 jquery 事件处理事件处理 on()绑定事件on()方法可以绑定一个或多个事件的事件处理函数 语法： 1element.on(events, [selector], fn); events:一个或多个用空格分隔的事件类型，如”click”或”keydown” selector:元素的子元素选择器 fn：回调函数 及绑定在元素身上的监听函数 on()方法优势 1：可以绑定多个事件，多个事件处理程序。 12345$(&quot;div&quot;).on(&#123; mouseover: function () &#123;&#125;, mouseout: function () &#123;&#125;, click: function () &#123;&#125;,&#125;); 如果事件处理程序相同 123$(&quot;div&quot;).on(&quot;mouseover mouseout&quot;, function () &#123; $(this).toggleClass(&quot;current&quot;);&#125;); on()方法优势 2：可以事件委派操作，事件委派的定义是，把原来加给子元素身上的事件绑定在父元素身上，就是把事件委派给父元素 123$(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function () &#123; alert(&quot;hello world!&quot;);&#125;); 在此之前有 bind(),live(),delegate()等方法来处理事件绑定或者事件委派，最新版本用 on 来代替他们 on()方法优势 3：动态创建的元素，click()没有办法绑定事件，on()可以给动态生成的元素绑定事件。 事件处理 off()解绑事件off()方法可以移除通过 on()方法添加的事件处理程序 123$(&quot;p&quot;).off(); //解绑p元素所有事件处理程序$(&quot;p&quot;).off(&quot;click&quot;); //解绑p元素上面的点击事件$(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;); //解绑事件委托 如果有的事件只想触发一次，可以使用 one()来绑定事件 自动触发事件 trigger()有些事件希望自动触发，比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。 1element.click(); //第一种简写形式 1element.trigger(&quot;type&quot;); //第二种自动触发模式 1234$(&quot;p&quot;).on(&quot;click&quot;, function () &#123; alert(&quot;hi&quot;);&#125;);$(&quot;p&quot;).trigger(&quot;click&quot;); //此时自动触发事件，不需要鼠标点击 1element.triggerHandler(type); //第三种自动触发模式，会阻止元素默认行为 事件对象事件被触发，就会有事件对象的产生 1element.on(events, [selector], function (event) &#123;&#125;); 阻止默认行为：event.preventDefault() 或者 return false阻止冒泡：event.stopPropagation() jquery 其他方法jquery 对象拷贝如果想要把某个对象拷贝(合并)给另外一个对象使用，此时可以用$.extend()方法语法： 1$.extend([deep], target, object1, [objectN]); deep:如果设为 true 为深拷贝，默认为 false 浅拷贝 target：要拷贝的目标对象 object：待拷贝到第一个对象的对象 objectN： 待拷贝到第 N 个对象的对象 浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象该目标对象会影响被拷贝的对象 深拷贝，前面加 true，完全克隆(拷贝的对象，而不是地址)，修改目标对象不会影响被拷贝对象。 jquery 多库共存问题概述：jQuery 使用 $作为标识符随着 jQuery 的流行，其他库也会使用$作为标识符，这样一起用会引起冲突 客观需求：需要一个解决方案，让 jquery 和其他的 js 库不存在冲突，可以同时存在，这就叫做多库共存 jquery 解决方案 把里面的$统一改为 jQuery。比如 jQuery(“div”) jQuery 变量规定新的名称： 1$.noConfct() var xx=$.noConfct(); jQuery 插件jQuery 功能比较有限，想要更复杂的特效效果可以借助于 jQue 插件完成。注意:这些插件也是依赖于 jQuery 来完成的，所以必须要先引入 jQuery 文件，因此也称为 jQuery 插件 jQuery 插件常用的网站 jQuery 插件库： http://www.jq22.com jQuery 之家: http://www.htmleaf.com","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://example.com/tags/jQuery/"}]},{"title":"flex布局","date":"2022-02-22T03:03:07.000Z","path":"2022/02/22/flex布局/","text":"常见父项属性以下6个属性是对父元素设置的 属性 作用 flex-direction 设置主轴方向 justify-content 设置主轴上的子元素排列方向 flex-wrap 设置子元素是否换行 align-content 设置侧轴上的子元素排列方式（多行） align-items 设置侧轴上的子元素排列方式（单行） flex-flow 复合属性，相当于同时设置了flex-driection和flex-wrap flex-direction 设置主轴方向1.主轴和侧轴在flex布局中，是分为主轴和侧轴两个方向，同样的叫法有：行和列，x轴和y轴 默认的主轴方向就是x轴方向，水平向右 默认的副轴方向就是y轴方向，水平向下 2.属性值 flex-direction属性决定主轴的方向（即项目的排列方向）注意： 主轴和侧轴是会变化的，就看flex-direction设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的 属性值 说明 row 从左到右（默认值） row-reverse 从右到左 column 从上到下 column-reverse 从下到上 justify-content 设置主轴上子元素的排列方式justify-content属性定义了项目在主轴上的对齐方式 注意： 使用这个属性之前一定要确定好主轴是哪个 属性值 说明 flex-start 默认值，如果主轴是x轴，则从左到右 flex-end 从尾部开始pai排列 center 主轴居中对齐 space-around 平分剩余空间 space-between 先两边贴合，再平分剩余空间 flex-wrap设置子元素是否换行默认情况下，项目都排在一条线（轴线）上。flex布局默认不换行 属性值 说明 nowrap 默认值，不换行 wrap 换行 align-items设置侧轴上的子元素排列方式（单行）该属性数控制子项在侧轴（默认y轴）上的排列方式，该子项为单项的时候使用 属性值 说明 flex-start 默认值 从上到下 flex-end 从下到上 center 挤在一起居中（垂直居中） stretch 拉伸 align-content 设置侧轴上的子元素的排列方式（多行）设置子项在侧轴上的排列方式，并且只能用于子项出现换行的情况（多行），在单行下是没有效果的 属性值 说明 flex-start 默认值 在侧轴的头部开始排列 flex-end 在侧轴的尾部开始排列 center 在侧轴中间显示 space-around 子项在侧轴平分剩余空间 space-between 子项在侧轴先分布在两头，再平分剩余空间 stretch 设置子项元素高度平分父元素高度 总结：单行用align-items，多行用align-content flex-flowflex-flow属性是flex-direction和flex-wrap属性的复合属性 1flex-flow: column wrap; flex布局子项常见属性 flex子项目占的份数 align-self控制子项自己在侧轴的排列方式 order属性定义子项的排列顺序（前后顺序） flex属性flex属性定义子项目分配剩余空间，用flex来表示占多少份数 123.item&#123; flex: &lt;number&gt;;&#125; align-self 控制子项自己在侧轴上的排列方式align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性，如果没有父元素，则等同于stretch 1234span&#123; /* 设置自己在侧轴上的排列方式 */ align-self: flex-end;&#125; order属性定义项目的排列顺序数值越小，排列越靠前，默认为0 注意： 和z-index不一样","tags":[{"name":"flex","slug":"flex","permalink":"http://example.com/tags/flex/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"当我真正开始爱自己","date":"2021-11-16T12:01:50.000Z","path":"2021/11/16/当我真正开始爱自己/","text":"当我真正开始爱自己 卓别林当我真正开始爱自己，我才认识到，所有的痛苦和情感的折磨，都只是提醒我：活着，不要违背自己的本心。今天我明白了，这叫做“真实”。 当我真正开始爱自己，我才懂得，把自己的愿望强加于人，是多么的无礼，就算我知道，时机并不成熟，那人也还没有做好准备，就算那个人就是我自己。今天我明白了，这叫做“尊重”。 当我开始爱自己，我不再渴求不同的人生，我知道任何发生在我身边的事情，都是对我成长的邀请。如今，我称之为“成熟”。 当我开始真正爱自己，我才明白，我其实一直都在正确的时间，正确的地方，发生的一切都恰如其分。由此我得以平静。今天我明白了，这叫做“自信”。 当我真正开始爱自己，我不再牺牲自己的自由时间，不再去勾画什么宏伟的明天。今天我只做有趣和快乐的事，做自己热爱，让心欢喜的事，用我的方式、我的韵律。今天我明白了，这叫做“单纯”。 当我开始真正爱自己，我开始远离一切不健康的东西。不论是饮食和人物，还是事情和环境，我远离一切让我远离本真的东西。从前我把这叫做“追求健康的自私自利”，但今天我明白了，这是“自爱”。 当我开始真正爱自己，我不再总想着要永远正确，不犯错误。我今天明白了，这叫做“谦逊”。 当我开始真正爱自己，我不再继续沉溺于过去，也不再为明天而忧虑，现在我只活在一切正在发生的当下，今天，我活在此时此地，如此日复一日。这就叫“完美”。 当我开始真正爱自己，我明白，我的思虑让我变得贫乏和病态，但当我唤起了心灵的力量，理智就变成了一个重要的伙伴，这种组合我称之为，“心的智慧”。 我们无须再害怕自己和他人的分歧，矛盾和问题，因为即使星星有时也会碰在一起，形成新的世界，今天我明白，这就是“生命”","tags":[{"name":"诗","slug":"诗","permalink":"http://example.com/tags/%E8%AF%97/"}]},{"title":"hexo常用命令","date":"2021-09-09T05:49:28.000Z","path":"2021/09/09/hexo常用命令/","text":"常见命令 命令 作用 hexo new “postName” 新建文章 hexo generate 生成静态页面至public目录 hexo server 开启预览访问端口 hexo deploy 部署到GitHub hexo help 查看帮助 hexo version 查看Hexo的版本 hexo clean 清理public的内容 缩写 缩写 相当于 hexo n hexo new hexo g hexo generate hexo s hexo server hexo d hexo deploy 组合命令 命令 作用 hexo s -g 生成并本地预览 hexo d -g 生成并上传","tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"first blog","date":"2021-09-09T05:43:12.000Z","path":"2021/09/09/first/","text":"test this is a blog test","tags":[{"name":"first","slug":"first","permalink":"http://example.com/tags/first/"}]}]